---
title: js RegExp正则表达式的使用
date: 2017-05-17 14:58:45
tags: js
categories: 前端
toc: true
---

首先，正则表达式 这个东西是干嘛用的？
比如我要判断用户输入的邮箱是否合法，或者我们想提取字符串里的某个特定字符，那么我们就可以用正则表达式来解决这些问题了。
正则表达式是一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串就是匹配了，否则该字符串不合法。
<!-- more -->

# 匹配规则

*  \d 匹配一个数字，如 '0a\d'可匹配‘0a8’,不能匹配‘0aa’;  '\d\d'可匹配'66'；

*  \w 匹配一个字母或者数字，如'0a\w'既可匹配'0a8',还可匹配‘0aa’;  '\w\w\w'可匹配'11a','aaa' ；

*  . 匹配任意字符，如'wh.'可匹配'whd','whx','wh!','wh8'等等；

*  \* 匹配任意个字符（包括0个）；

*  \+ 匹配至少1个字符

*  ？匹配0或者1个字符

*  i忽略大小写匹配

*  m多行匹配

*  \s 匹配一个空格（包括Tab等空白符）

*  {n}匹配n个字符，'\d{4}'匹配4个数字，比如'0755'

*  {n,m}匹配n-m个字符,'\d{3,8}'可匹配3-8个数字，如'1234','123','12345678' ; 

*  [] 表示范围匹配，这样可以做到更精准匹配，[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串,比如'a9f','a_0','2017';

* A|B 可以匹配A或B，所以'(J|j)s'可以匹配'Js'和'js' ;

*  ^表示行的开头，'^\d'表示以数字开头；

*  $表示行结束，'\d$'表示以数字结束；js可以匹配'jsp',加上'^js$'后只能匹配'js'了；

*  ()表示分组；
  
JavaScript正则表达式创建的方式有两种：

第一种是通过 /正则表达式/ 形式写出来， 第二种是通过new RegExp('正则表达式')。两种方式是一样的：

``` javascript
var re1 = /whd\88188/;

var re2 = new RegExp('whd\\88188'); // 注意这种方法需要转义，两个\\其实是一个\

re1; // /whd|88188/

re2; // /whd|88188/
```

# 如何判断正则表达式是否匹配
``` javascript
var re = /^\d{4}\-\d{3-8}$/;

re.test('0755-88188'); // true

re.test('075-88188'); // false

re.test('0755-88188whd'); // false
```
RegExp对象的test()方法用于检测字符串是否符合条件。


# 如何切割字符串
split()方法用于切割字符串，切割例子如下：
``` javascript
'w h d'.split(''); // ['w','','h','','d']
```
发现没有，无法识别空格，来，加点正则表达式
``` javascript
'w h d'.split(/\s+/);  // ['w','h','d']
```
加上，；试试
``` javascript
'w,h;; d'.split(/[\s\,\;]+/); // ['w','h','d']
```

 可以用split()方法把不规范地输入转化为规范地输入。


# 如何提取子串
用exec()方法提取子串，如我们要提取区号和本地号码
``` javascript
var re = /^(\d{4})-(\d{3,8})$/;
re.exec('0755-123456'); // ['0755-123456', '0755', '123456']
re.exec('0755 123456'); // null
```
exec()方法匹配成功后，回返回一个数组，第一个元素是正则表达式匹配到的整个字符串，后面是匹配成功的子串。

# 贪婪匹配
正则表大式默认贪婪匹配，它会匹配尽可能多的字符，举个栗子，要匹配出数字后面所有的0
``` javascript
var re = /^(\d+)(0*)$/;
re.exec('1023000');  // ["1023000","1023000",""]
```
因为 \d+采用的是贪婪匹配，把'1023000'所有的数字都匹配了，结果0*匹配了空字符串，现在要不匹配所有数字，就得让\d+变成非贪婪匹配，加？能实现
``` javascript
var re = /^(\d+？)(0*)$/;
re.exec('1023000');  // ["1023000","1023","000"]
```

# 全局搜索
g表示全局匹配
``` javascript
var re1 = /whd88188/g ; 

var re2 = new RegExp('whd88188','g');
```
这两种表达方式是等价的

全局匹配可以用exec()方法来搜索一个匹配的字符串，指定g标志后，每次运行exec(),正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引，

``` javascript
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

遇到经常过来回顾回顾……嗯，确定你过段时间还记得这篇文章？
